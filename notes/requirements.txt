This project uses my existing Github code at https://github.com/whyaaronbailey/adafruit_rp2040_usbh.git. The existing code is firmware for an Adafruit RP2040 USB Host. 
It parses the input of keyboard, mouse, and HID devices on Core 1 of the RP2040,  uses FIFO to send to Core 0 where QMK firmware serves the following devices by default:

[1-3]: Adafruit Rp2040 USB Host
|---USB Input Device
|   \---HID-compliant vendor-defined device
|---USB Serial Device (COM Port)
|---USB Input Device
|   |---HID-compliant system controller
|   |---HID-compliant consumer control device
|   |---HID-compliant mouse
|   \---HID Keyboard Device
\---USB Input Device
    \---HID Keyboard Device

In this manner, the devices allows for QMK management of keyboards that were not designed for QMK. I have been using this with a Razer Tartarus v2 Pro keypad that is heavily customized for PACs (I am a radiologist),
as you can see in the keymap.c file attached.

The existing firmware uses TinyUSB and Pico-PIO-USB for the USB Host functionality. The device functionality is managed by QMK.

As a radiologist, I dictate with Powerscribe. In order to free my hands from having to hold and control a PowerMic, I have adopted 2.4ghz lavalier microphones. The objective is to emulate the button presses
of a PowerMic, without enumerating an entirely new device, such that Powerscribe will react to the button presses as if they were coming from a PowerMic. I have used USB capture and Wireshark tools to extract the 
information from the PowerMic. Because we are only interested in the button presses, we are focussing on those components of the device, with the complex audio, led, and other components not necessary for this project. 
Please remember this point.

The HID descriptor for the device is provided below, as well as a model HID descriptor for the device that has been repeatedly validated:

PowerMic HID Interface
•  Interface Number: 3 (Interface 3)
•  Endpoint Address: 0x81 (Endpoint 1 IN)
•  Endpoint Type: Interrupt
•  Endpoint Max Packet Size: As per the existing configuration
•  Polling Interval: 10ms

// PowerMic HID Report Descriptor
uint8_t const hid_report_desc_powermic[] = {
    // Usage Page (Generic Desktop Controls)
    0x05, 0x01,        // Usage Page (Generic Desktop Controls)
    0x09, 0x00,        // Usage (Undefined)
    0xA1, 0x01,        // Collection (Application)
    
    // LED Report - Included for compatibility but unused
    0x05, 0x08,        // Usage Page (LEDs)
    0x09, 0x4B,        // Usage (Generic Indicator)
    0x15, 0x00,        // Logical Minimum (0)
    0x25, 0x01,        // Logical Maximum (1)
    0x95, 0x08,        // Report Count (8)
    0x75, 0x01,        // Report Size (1)
    0x91, 0x02,        // Output (Data, Var, Abs)
    
    // Button Input Report
    0x05, 0x09,        // Usage Page (Button)
    0x15, 0x00,        // Logical Minimum (0)
    0x25, 0x01,        // Logical Maximum (1)
    0x75, 0x01,        // Report Size (1)
    0x95, 0x08,        // Report Count (8)
    0x81, 0x03,        // Input (Const, Var, Abs) - Padding

    // Button Usages
    0x19, 0x01,        // Usage Minimum (Button 1)
    0x29, 0x0E,        // Usage Maximum (Button 14)
    0x15, 0x00,        // Logical Minimum (0)
    0x25, 0x01,        // Logical Maximum (1)
    0x95, 0x0E,        // Report Count (14)
    0x81, 0x02,        // Input (Data, Var, Abs)

    // Padding
    0x95, 0x02,        // Report Count (2)
    0x81, 0x03,        // Input (Const, Var, Abs) - Padding

    // Vendor-Defined Feature Report
    0x06, 0x00, 0xFF,  // Usage Page (Vendor-Defined 0xFF00)
    0x09, 0x00,        // Usage (Undefined)
    0x15, 0x00,        // Logical Minimum (0)
    0x26, 0xFF, 0x00,  // Logical Maximum (255)
    0x75, 0x08,        // Report Size (8 bits)
    0x95, 0x27,        // Report Count (39 bytes)
    0xB1, 0x00,        // Feature (Data, Array, Abs)

    0xC0               // End Collection
};

A possible configuration descriptor is provided below:
// Configuration Descriptor with placeholders for Interface 0, 1, 2
uint8_t const desc_configuration[] = {
    // Configuration Descriptor
    0x09,                            // bLength
    TUSB_DESC_CONFIGURATION,         // bDescriptorType
     0x00, 0x00,                     // wTotalLength (will be calculated)
    ITF_NUM_TOTAL,                   // bNumInterfaces
    0x01,                            // bConfigurationValue
    0x00,                            // iConfiguration
    0xA0,                            // bmAttributes (Bus-powered, Remote Wakeup)
    0xFA,                            // bMaxPower (500 mA)

    // Interface 0: Placeholder
    TUD_INTERFACE_DESCRIPTOR(0, 0x03, 0x00, 0x00, 0x00, 0x00), // Class 0x03 = HID

    // Interface 1: USB Serial Device (COM Port)
     TUD_INTERFACE_DESCRIPTOR(1, 0x02, 0x02, 0x01, 0x00, 0x00), // Class 0x02=CDC, Subclass=0x02, Protocol=0x01
  
    // Interface 2: HID-compliant system controller/consumer/mouse/keyboard
    TUD_INTERFACE_DESCRIPTOR(2, 0x03, 0x00, 0x00, 0x00, 0x00),  // Class 0x03 = HID

    // Interface 3: PowerMic HID
    TUD_HID_DESCRIPTOR(ITF_NUM_POWERMIC, 0x00, HID_ITF_PROTOCOL_NONE,
                       sizeof(hid_report_desc_powermic), EPNUM_POWERMIC, CFG_TUD_HID_EP_BUFSIZE, 10),

    // Interface 4: Keyboard HID
    TUD_HID_DESCRIPTOR(ITF_NUM_KEYBOARD, 0x00, HID_ITF_PROTOCOL_KEYBOARD,
                       sizeof(hid_report_desc_keyboard), EPNUM_KEYBOARD, CFG_TUD_HID_EP_BUFSIZE, 10),
};


This is the data resulting from the PowerMic button presses. All releases are {0x00, 0x00, 0x00}.
    Button Codes (3-byte Values)
    •  Enter/Select: {0x00, 0x00, 0x01}
    •  Custom Right: {0x00, 0x00, 0x02}
    •  Transcribe: {0x00, 0x01, 0x00}
    •  Tab Back: {0x00, 0x02, 0x00}
    •  Dictate: {0x00, 0x04, 0x00}
    •  Tab Forward: {0x00, 0x08, 0x00}
    •  Rewind: {0x00, 0x10, 0x00}
    •  Fast Forward: {0x00, 0x20, 0x00}
    •  Stop/Play: {0x00, 0x40, 0x00}
    •  Custom Left: {0x00, 0x80, 0x00}
    •  Trigger: {0x01, 0x00, 0x00}
    •  Release: {0x00, 0x00, 0x00}

    static const uint8_t PM_ENTER_CODE[3]      = {0x00, 0x00, 0x01};
    static const uint8_t PM_CUSTOM_R_CODE[3]   = {0x00, 0x00, 0x02};
    static const uint8_t PM_TRANSCRIBE_CODE[3] = {0x00, 0x01, 0x00};
    static const uint8_t PM_TAB_BACK_CODE[3]   = {0x00, 0x02, 0x00};
    static const uint8_t PM_DICTATE_CODE[3]    = {0x00, 0x04, 0x00};
    static const uint8_t PM_TAB_FWD_CODE[3]    = {0x00, 0x08, 0x00};
    static const uint8_t PM_REWIND_CODE[3]     = {0x00, 0x10, 0x00};
    static const uint8_t PM_FFWD_CODE[3]       = {0x00, 0x20, 0x00};
    static const uint8_t PM_STOP_PLAY_CODE[3]  = {0x00, 0x40, 0x00};
    static const uint8_t PM_CUSTOM_L_CODE[3]   = {0x00, 0x80, 0x00};
    static const uint8_t PM_TRIGGER_CODE[3]    = {0x01, 0x00, 0x00};
    static const uint8_t PM_RELEASE_CODE[3]    = {0x00, 0x00, 0x00};

Report Format
•  Report Length: 3 bytes [Byte1][Byte2][Byte3]
•  Button Press Report: Send the corresponding button code.
•  Button Release Report: Send {0x00, 0x00, 0x00}
Timing Characteristics
•  Button Press Duration: 120ms ±5ms
•  Interrupt Polling Interval: 10ms
•  Response Time: Device must respond to host requests within 1ms
•  Minimum Time Between Reports: 10ms

Our obective: 
1.  Emulate the PowerMic Button Interface (Not the Device): Cause Powerscribe to react in the same manner as it would when the buttons on a PowerMic are pressed.
    This would be achieved by providing an identical interface, reports, and data for the button presses and releases.
2.  Do Not Emulate the PowerMic Device Identity: The device should not present itself as a PowerMic. All device identifiers such as the VID, PID, manufacturer, product name, and version must remain as 
per info.json.

Because a press is on the PowerMic is actually a press then a release of the button, the following code structure for keymap.c will be implemented. You do not need to
implement a new keymap.c file.

        Example Implementation:
        #include QMK_KEYBOARD_H
        #include "tusb.h"

        // Define custom keycodes
        enum custom_keycodes {
            PM_ENTER = SAFE_RANGE,
            PM_CUSTOM_R,
            PM_TRANSCRIBE,
            // ... other custom keycodes
        };

        // PowerMic button codes
        static const uint8_t PM_ENTER_CODE[3]      = {0x00, 0x00, 0x01};
        static const uint8_t PM_CUSTOM_R_CODE[3]   = {0x00, 0x00, 0x02};
        static const uint8_t PM_RELEASE_CODE[3]    = {0x00, 0x00, 0x00};
        // ... other button codes

        // Function to process PowerMic button presses
        void process_powermic_button(const uint8_t* button_code) {
            // Send the button press report
            tud_hid_n_report(ITF_NUM_POWERMIC, 0, button_code, 3);

            // Wait for 120ms ±5ms
            wait_ms(120);

            // Send the release report
            tud_hid_n_report(ITF_NUM_POWERMIC, 0, PM_RELEASE_CODE, 3);
        }

        // Process custom keycodes
        bool process_record_user(uint16_t keycode, keyrecord_t *record) {
            if (record->event.pressed) {
                switch (keycode) {
                    case PM_ENTER:
                        process_powermic_button(PM_ENTER_CODE);
                        return false;
                    case PM_CUSTOM_R:
                        process_powermic_button(PM_CUSTOM_R_CODE);
                        return false;
                    // ... other cases
                }
            }
            return true;
        }



OBJECTIVES:

1. Emulate press and release of PowerMic buttons on the DEVICE side (Core 0) such that the host application, Powerscribe, reacts as if an actual PowerMic button press and release occured. 
    * We are not emulating a PowerMic device.
    * We are not hosting a PowerMic, or parsing any inputs from a PowerMic.
    * We have tried raw-hid -- it does not work because it is restricted to 32 byte reports (we need 3 bytes).
    * we have 
    * We will likely have to enable device mode in tusb_config.h to be able to use tud_hid_send_report() macros.
    * The Powermic uses a 3 byte report format. We are only concerned with the button portion of the device and report; the audio and LED portions are not relevant.
    
2. Send the correctly structured report to the host application over endPoint 0x81.
    * The device without Powermic code enumerates as multiple devices, as previously mentioned. These are managed by QMK. 
    * Make sure there are no endpoint conflicts.

3. Do not alter the functionality of host code and of QMK. 

4. Do not alter any code outside of this project. We cannot alter core QMK code or any library code.
    * QMK manages its own usb_descriptors.C
    * The project file doees no include its own usb_descriptors.c; one would have to be created.
    * No conflicts between endpoints. No conflicts between interfaces. 

5. You do not need to focus on keymap.c. Focus on the how this would be implemented. 
    * Should we piggyback on an existing interface?
    * Should we create a new interface?

6. Architect a complete solution. Be able to concisely describe the solution (in 10 bullets).
 a. Consult QMK, TinyUSB documentation
 b. Consult other github repositories where similar interfaces may have been added to QMK, or where PowerMic emulation has been implemented.
 c. Develop all necessary code to implement the solution, including usb_descriptors.c, its headers, rules.mk, keymaps.c, tusb_config.h, and any other files that would be necessary.
 d. Validate it against these requirements.

7. If the code successfully implements the solution, satisfing each requirement, describe it in detail, and then provide the complete annotated code. 
* Remove copyright and unneeded comments.
* Format consistently.
* insure all includes are correct (consult documentation to verify)
* Ensure the the code will compile and run.

8. If the code does not successfully implement the complete solution and satisfy each requirement, 
* note it as iteration x, and record the 10 bullet explanation.
* repeat step 5, 6, 7, and 8 until the solution is complete.

9. Provide final solution.
* Report number of iterations.
* For each iteration, list its 10 bullet explanation.
* Provide detailed explanation of final solution.
* Provide the complete annotated, beautifully constructed, code.



Iteration 1:
    Initial Goal: We set out to create a USB-to-USB converter that would take keyboard input from a Razer Tartarus and send emulated PowerMic button presses to a host computer, using an Adafruit RP2040 USB Host board.
    Early Roadblocks: Initial attempts were complicated by incorrect assumptions about how TinyUSB's host and device stacks interact, leading to persistent compilation errors due to missing header files.
    Focus on rules.mk: We spent considerable effort trying to fix the issue by modifying rules.mk, specifically the VPATH and -I compiler flags, but initially failed to correctly configure the include paths.
    TinyUSB Device Stack Confusion: I mistakenly tried to use TinyUSB device-side descriptor macros (like TUD_HID_REPORT_DESC_KEYBOARD) when only the host stack was intended to be used, further compounding the compilation issues.
    usb_descriptors.c Errors: The compiler consistently threw errors related to "implicit declaration of function" and "initializer element is not constant" due to the incorrect use of TinyUSB device-side macros and incorrect relative paths.
    Raghur's Codebase: We incorporated changes and structure from Raghur's example, hoping it would provide a stable foundation. However, this did not resolve our core include path issues.
    Incorrect Header: We were attempting to include common/tusb_descriptors.h, which does not exist. The correct header with the descriptor-related definitions is within the TinyUSB library itself.
    String Descriptor Calculations: I also made errors in the calculations for the USB string descriptors, further adding to the confusion, these calculations were corrected along the way.
    Forgetting Previous Steps: Several times during the process, I made recommendations that contradicted or overlooked solutions/discoveries that were previously discussed, leading to unnecessary repetition and wasted effort.
    Current Status: After multiple attempts, we have determined that the best way forward is to use only the TinyUSB host stack, manually create the configuration descriptor, and use tuh_hid_n_report to send the PowerMic button reports.

Iteration 2:
    Initial Misunderstanding: The initial response fundamentally misunderstood the goal, attempting to implement PowerMic emulation on the host side (Core 1) instead of the device side (Core 0).
    Incorrect keymap.c Modifications: The initial keymap.c changes were largely correct but included unnecessary code while not addressing the need to send data over the new interface, instead relying on a fictional send_powermic_report_to_host() function.
    Missing usb_descriptors.c: The early attempts failed to create a usb_descriptors.c, instead trying to add everything to tusb_os_custom.c and thus complicating the project unnecessarily.
    Endpoint Conflict (First Time): The initial usb_descriptors.c created a conflict where both the CDC notification endpoint and the PowerMic endpoint had the same address (0x81).
    Incorrect TinyUSB Macro Usage (First Iteration): I made incorrect assumptions about TinyUSB macros, such as TUD_INTERFACE_DESCRIPTOR, TUD_ENDPOINT_DESCRIPTOR and attempted to use them like functions.
    Missing TinyUSB Includes (First Iteration): I failed to include TinyUSB headers (tusb.h, tusb_cdc.h, tusb_hid.h, etc.) in the usb_descriptors.c file where I was trying to use TinyUSB constants (e.g. TUD_HID_CLASS).
    Endpoint Conflict (Second Time): After addressing other issues, the endpoint conflict was overlooked, causing a subsequent failure.
    Incorrect TinyUSB Macro Usage (Second Iteration): I continued to use incorrect names for TinyUSB macros, such as TUD_HID_CLASS and TUD_CDC_CLASS, instead of the correct macros.
    Incorrect Include Path: I failed to correctly set the include paths in rules.mk to find the TinyUSB class headers, even after including them, resulting in compiler errors. This also included adding unnecessary / on the end of the paths.
    Incorrect Header Names: I failed to notice that the header file names were cdc.h and hid.h, not tusb_cdc.h and tusb_hid.h, which led to further include errors.

Iteration 3:





I am providing the following files from my code base:

info.json:
{
    "manufacturer": "Adafruit",
    "keyboard_name": "Rp2040 USB Host",
    "maintainer": "sekigon-gonnoc",
    "bootloader": "rp2040",
    "diode_direction": "COL2ROW",
    "features": {
        "bootmagic": false,
        "command": false,
        "console": true,
        "extrakey": true,
        "mousekey": true,
        "nkro": true,
        "virtser": true,
        "pointing_device": true
    },
    "qmk": {
        "tap_keycode_delay": 10
    },
    "matrix_pins": {
        "cols": [
            "NO_PIN", "NO_PIN", "NO_PIN", "NO_PIN", "NO_PIN", "NO_PIN", "NO_PIN", "NO_PIN"
        ],
        "rows": [
            "NO_PIN", "NO_PIN", "NO_PIN", "NO_PIN", "NO_PIN", "NO_PIN", "NO_PIN", "NO_PIN",
            "NO_PIN", "NO_PIN", "NO_PIN", "NO_PIN", "NO_PIN", "NO_PIN", "NO_PIN", "NO_PIN",
            "NO_PIN", "NO_PIN", "NO_PIN", "NO_PIN", "NO_PIN", "NO_PIN", "NO_PIN", "NO_PIN",
            "NO_PIN", "NO_PIN", "NO_PIN", "NO_PIN", "NO_PIN", "NO_PIN", "NO_PIN", "NO_PIN",
            "NO_PIN", "NO_PIN", "NO_PIN", "NO_PIN"
        ]
    },
    "processor": "RP2040",
    "usb": {
        "vid": "0x239A",
        "pid": "0x0001",
        "device_version": "1.0.0"
    },
    "layouts": {
        "LAYOUT_fullsize_ansi": {
            "layout": [
                {"matrix": [5, 1], "x": 0, "y": 0, "label": "KC_ESC"},
                {"matrix": [7, 2], "x": 2, "y": 0, "label": "KC_F1"},
                {"matrix": [7, 3], "x": 3, "y": 0, "label": "KC_F2"},
                {"matrix": [7, 4], "x": 4, "y": 0, "label": "KC_F3"},
                {"matrix": [7, 5], "x": 5, "y": 0, "label": "KC_F4"},
                {"matrix": [7, 6], "x": 6.5, "y": 0, "label": "KC_F5"},
                {"matrix": [7, 7], "x": 7.5, "y": 0, "label": "KC_F6"},
                {"matrix": [8, 0], "x": 8.5, "y": 0, "label": "KC_F7"},
                {"matrix": [8, 1], "x": 9.5, "y": 0, "label": "KC_F8"},
                {"matrix": [8, 2], "x": 11, "y": 0, "label": "KC_F9"},
                {"matrix": [8, 3], "x": 12, "y": 0, "label": "KC_F10"},
                {"matrix": [8, 4], "x": 13, "y": 0, "label": "KC_F11"},
                {"matrix": [8, 5], "x": 14, "y": 0, "label": "KC_F12"},
                {"matrix": [8, 6], "x": 15.25, "y": 0, "label": "KC_PSCR"},
                {"matrix": [8, 7], "x": 16.25, "y": 0, "label": "KC_SCRL"},
                {"matrix": [9, 0], "x": 17.25, "y": 0, "label": "KC_PAUS"},
                {"matrix": [6, 5], "x": 0, "y": 1.5, "label": "KC_GRV"},
                {"matrix": [3, 6], "x": 1, "y": 1.5, "label": "KC_1"},
                {"matrix": [3, 7], "x": 2, "y": 1.5, "label": "KC_2"},
                {"matrix": [4, 0], "x": 3, "y": 1.5, "label": "KC_3"},
                {"matrix": [4, 1], "x": 4, "y": 1.5, "label": "KC_4"},
                {"matrix": [4, 2], "x": 5, "y": 1.5, "label": "KC_5"},
                {"matrix": [4, 3], "x": 6, "y": 1.5, "label": "KC_6"},
                {"matrix": [4, 4], "x": 7, "y": 1.5, "label": "KC_7"},
                {"matrix": [4, 5], "x": 8, "y": 1.5, "label": "KC_8"},
                {"matrix": [4, 6], "x": 9, "y": 1.5, "label": "KC_9"},
                {"matrix": [4, 7], "x": 10, "y": 1.5, "label": "KC_0"},
                {"matrix": [5, 5], "x": 11, "y": 1.5, "label": "KC_MINS"},
                {"matrix": [5, 6], "x": 12, "y": 1.5, "label": "KC_EQL"},
                {"matrix": [5, 2], "x": 13, "y": 1.5, "w": 2, "label": "KC_BSPC"},
                {"matrix": [9, 1], "x": 15.25, "y": 1.5, "label": "KC_INS"},
                {"matrix": [9, 2], "x": 16.25, "y": 1.5, "label": "KC_HOME"},
                {"matrix": [9, 3], "x": 17.25, "y": 1.5, "label": "KC_PGUP"},
                {"matrix": [10, 3], "x": 18.5, "y": 1.5, "label": "KC_NUM"},
                {"matrix": [10, 4], "x": 19.5, "y": 1.5, "label": "KC_PSLS"},
                {"matrix": [10, 5], "x": 20.5, "y": 1.5, "label": "KC_PAST"},
                {"matrix": [10, 6], "x": 21.5, "y": 1.5, "label": "KC_PMNS"},
                {"matrix": [5, 3], "x": 0, "y": 2.5, "w": 1.5, "label": "KC_TAB"},
                {"matrix": [2, 4], "x": 1.5, "y": 2.5, "label": "KC_Q"},
                {"matrix": [3, 2], "x": 2.5, "y": 2.5, "label": "KC_W"},
                {"matrix": [1, 0], "x": 3.5, "y": 2.5, "label": "KC_E"},
                {"matrix": [2, 5], "x": 4.5, "y": 2.5, "label": "KC_R"},
                {"matrix": [2, 7], "x": 5.5, "y": 2.5, "label": "KC_T"},
                {"matrix": [3, 4], "x": 6.5, "y": 2.5, "label": "KC_Y"},
                {"matrix": [3, 0], "x": 7.5, "y": 2.5, "label": "KC_U"},
                {"matrix": [1, 4], "x": 8.5, "y": 2.5, "label": "KC_I"},
                {"matrix": [2, 2], "x": 9.5, "y": 2.5, "label": "KC_O"},
                {"matrix": [2, 3], "x": 10.5, "y": 2.5, "label": "KC_P"},
                {"matrix": [5, 7], "x": 11.5, "y": 2.5, "label": "KC_LBRC"},
                {"matrix": [6, 0], "x": 12.5, "y": 2.5, "label": "KC_RBRC"},
                {"matrix": [6, 1], "x": 13.5, "y": 2.5, "w": 1.5, "label": "KC_BSLS"},
                {"matrix": [9, 4], "x": 15.25, "y": 2.5, "label": "KC_DEL"},
                {"matrix": [9, 5], "x": 16.25, "y": 2.5, "label": "KC_END"},
                {"matrix": [9, 6], "x": 17.25, "y": 2.5, "label": "KC_PGDN"},
                {"matrix": [11, 7], "x": 18.5, "y": 2.5, "label": "KC_P7"},
                {"matrix": [12, 0], "x": 19.5, "y": 2.5, "label": "KC_P8"},
                {"matrix": [12, 1], "x": 20.5, "y": 2.5, "label": "KC_P9"},
                {"matrix": [10, 7], "x": 21.5, "y": 2.5, "h": 2, "label": "KC_PPLS"},
                {"matrix": [7, 1], "x": 0, "y": 3.5, "w": 1.75, "label": "KC_CAPS"},
                {"matrix": [0, 4], "x": 1.75, "y": 3.5, "label": "KC_A"},
                {"matrix": [2, 6], "x": 2.75, "y": 3.5, "label": "KC_S"},
                {"matrix": [0, 7], "x": 3.75, "y": 3.5, "label": "KC_D"},
                {"matrix": [1, 1], "x": 4.75, "y": 3.5, "label": "KC_F"},
                {"matrix": [1, 2], "x": 5.75, "y": 3.5, "label": "KC_G"},
                {"matrix": [1, 3], "x": 6.75, "y": 3.5, "label": "KC_H"},
                {"matrix": [1, 5], "x": 7.75, "y": 3.5, "label": "KC_J"},
                {"matrix": [1, 6], "x": 8.75, "y": 3.5, "label": "KC_K"},
                {"matrix": [1, 7], "x": 9.75, "y": 3.5, "label": "KC_L"},
                {"matrix": [6, 3], "x": 10.75, "y": 3.5, "label": "KC_SCLN"},
                {"matrix": [6, 4], "x": 11.75, "y": 3.5, "label": "KC_QUOT"},
                {"matrix": [5, 0], "x": 12.75, "y": 3.5, "w": 2.25, "label": "KC_ENT"},
                {"matrix": [11, 4], "x": 18.5, "y": 3.5, "label": "KC_P1"},
                {"matrix": [11, 5], "x": 19.5, "y": 3.5, "label": "KC_P2"},
                {"matrix": [11, 6], "x": 20.5, "y": 3.5, "label": "KC_P3"},
                {"matrix": [28, 1], "x": 0, "y": 4.5, "w": 2.25, "label": "KC_LSFT"},
                {"matrix": [3, 5], "x": 2.25, "y": 4.5, "label": "KC_Z"},
                {"matrix": [3, 3], "x": 3.25, "y": 4.5, "label": "KC_X"},
                {"matrix": [0, 6], "x": 4.25, "y": 4.5, "label": "KC_C"},
                {"matrix": [3, 1], "x": 5.25, "y": 4.5, "label": "KC_V"},
                {"matrix": [0, 5], "x": 6.25, "y": 4.5, "label": "KC_B"},
                {"matrix": [2, 1], "x": 7.25, "y": 4.5, "label": "KC_N"},
                {"matrix": [2, 0], "x": 8.25, "y": 4.5, "label": "KC_M"},
                {"matrix": [6, 6], "x": 9.25, "y": 4.5, "label": "KC_COMM"},
                {"matrix": [6, 7], "x": 10.25, "y": 4.5, "label": "KC_DOT"},
                {"matrix": [7, 0], "x": 11.25, "y": 4.5, "label": "KC_SLSH"},
                {"matrix": [28, 5], "x": 12.25, "y": 4.5, "w": 2.75, "label": "KC_RSFT"},
                {"matrix": [10, 2], "x": 16.25, "y": 4.5, "label": "KC_UP"},
                {"matrix": [11, 1], "x": 18.5, "y": 4.5, "label": "KC_P1"},
                {"matrix": [11, 2], "x": 19.5, "y": 4.5, "label": "KC_P2"},
                {"matrix": [11, 3], "x": 20.5, "y": 4.5, "label": "KC_P3"},
                {"matrix": [11, 0], "x": 21.5, "y": 4.5, "h": 2, "label": "KC_PENT"},
                {"matrix": [28, 0], "x": 0, "y": 5.5, "w": 1.25, "label": "KC_LCTL"},
                {"matrix": [28, 3], "x": 1.25, "y": 5.5, "w": 1.25, "label": "KC_LGUI"},
                {"matrix": [28, 2], "x": 2.5, "y": 5.5, "w": 1.25, "label": "KC_LALT"},
                {"matrix": [5, 4], "x": 3.75, "y": 5.5, "w": 6.25, "label": "KC_SPC"},
                {"matrix": [28, 6], "x": 10, "y": 5.5, "w": 1.25, "label": "KC_RALT"},
                {"matrix": [28, 7], "x": 11.25, "y": 5.5, "w": 1.25, "label": "KC_RGUI"},
                {"matrix": [12, 5], "x": 12.5, "y": 5.5, "w": 1.25, "label": "KC_APP"},
                {"matrix": [28, 4], "x": 13.75, "y": 5.5, "w": 1.25, "label": "KC_RCTL"},
                {"matrix": [10, 0], "x": 15.25, "y": 5.5, "label": "KC_LEFT"},
                {"matrix": [10, 1], "x": 16.25, "y": 5.5, "label": "KC_DOWN"},
                {"matrix": [9, 7], "x": 17.25, "y": 5.5, "label": "KC_RGHT"},
                {"matrix": [12, 2], "x": 18.5, "y": 5.5, "w": 2, "label": "KC_P0"},
                {"matrix": [12, 3], "x": 20.5, "y": 5.5, "label": "KC_PDOT"}
            ]
        },

        "LAYOUT_tartarus2": {
            "layout": [
                // Row 0
                {"matrix": [3,6], "x": 0, "y": 0, "label": "01-KC_1"},
                {"matrix": [3,7], "x": 1, "y": 0, "label": "02-KC_2"},
                {"matrix": [4,0], "x": 2, "y": 0, "label": "03-KC_3"},
                {"matrix": [4,1], "x": 3, "y": 0, "label": "04-KC_4"},
                {"matrix": [4,2], "x": 4, "y": 0, "label": "05-KC_5"},

                // Row 1
                {"matrix": [5,3], "x": 0, "y": 1, "label": "06-KC_TAB"},
                {"matrix": [2,4], "x": 1, "y": 1, "label": "07-KC_Q"},
                {"matrix": [3,2], "x": 2, "y": 1, "label": "08-KC_W"},
                {"matrix": [1,0], "x": 3, "y": 1, "label": "09-KC_E"},
                {"matrix": [2,5], "x": 4, "y": 1, "label": "10-KC_R"},

                // Row 2
                {"matrix": [7,1], "x": 0, "y": 2, "label": "11-KC_CAPS"},
                {"matrix": [0,4], "x": 1, "y": 2, "label": "12-KC_A"},
                {"matrix": [2,6], "x": 2, "y": 2, "label": "13-KC_S"},
                {"matrix": [0,7], "x": 3, "y": 2, "label": "14-KC_D"},
                {"matrix": [1,1], "x": 4, "y": 2, "label": "15-KC_F"},

                // Row 3
                {"matrix": [28,1], "x": 0, "y": 3, "label": "16-KC_LSFT"},
                {"matrix": [3,5], "x": 1, "y": 3, "label": "17-KC_Z"},
                {"matrix": [3,3], "x": 2, "y": 3, "label": "18-KC_X"},
                {"matrix": [0,6], "x": 3, "y": 3, "label": "19-KC_C"},

                // Additional Keys
                {"matrix": [13,1], "x": 5, "y": 1, "label": "SW-KC_TRNS"},
                {"matrix": [13,0], "x": 5, "y": 2, "label": "SC-KC_TRNS"},
                {"matrix": [28,2], "x": 5, "y": 0, "label": "thumb-KC_LALT"},
                {"matrix": [5,4], "x": 4, "y": 3, "w": 2, "label": "20-KC_SPC"},

                // Arrow Keys
                {"matrix": [10,0], "x": 6, "y": 0, "label": "DPAD_LEFT-KC_LEFT"},
                {"matrix": [9,7], "x": 6, "y": 1, "label": "DPAD_RIGHT-KC_RGHT"},
                {"matrix": [10,2], "x": 6, "y": 2, "label": "DPAD_UP-KC_UP"},
                {"matrix": [10,1], "x": 6, "y": 3, "label": "DPAD_DOWN-KC_DOWN"}
            ]
        }
    }
}




tusb_config.h:
#ifndef _TUSB_CONFIG_H_
#define _TUSB_CONFIG_H_

#ifdef __cplusplus
 extern "C" {
#endif
#define CFG_TUSB_OS               OPT_OS_CUSTOM
#define CFG_TUSB_MCU              OPT_MCU_RP2040
#define CFG_TUSB_DEBUG 0
#define CFG_TUSB_DEBUG_PRINTF tusb_debug_printf
#define CFG_TUD_ENABLED     0
#define CFG_TUH_ENABLED     1
#define CFG_TUH_RPI_PIO_USB 1
#ifndef CFG_TUSB_MEM_SECTION
#define CFG_TUSB_MEM_SECTION
#endif

#ifndef CFG_TUSB_MEM_ALIGN
#define CFG_TUSB_MEM_ALIGN          __attribute__ ((aligned(4)))
#endif
#define CFG_TUH_ENUMERATION_BUFSIZE 256
#define CFG_TUH_HUB                 1
#define CFG_TUH_DEVICE_MAX          (CFG_TUH_HUB ? 4 : 1) // hub typically has 4 ports
#define CFG_TUH_HID                  8
#define CFG_TUH_HID_EPIN_BUFSIZE    64
#define CFG_TUH_HID_EPOUT_BUFSIZE   64
#ifdef __cplusplus
 }
#endif
#endif /* _TUSB_CONFIG_H_ */




keymaps/tartarus2_pacs/keymap.c:
// SPDX-License-Identifier: GPL-2.0-or-later
#include QMK_KEYBOARD_H

enum custom_keycodes {
	COPYACC = SAFE_RANGE,
	OPENGE,
	OPENEPIC,
    OPENMCKESSON,
	PASTE,
	DICTATE,
	WL_SOFT,
	WL_BONE,
	WL_BRAIN,
	WL_STROKE,
	WL_LUNG,
	WL_VASCULAR,
    WL_SUBDURAL,
	WL_HARDWARE,
	ARROW,
	ZOOM,
	MEASURE,
	SCROLLUP,
	SCROLLDOWN,
	WHEELUP,
	WHEELDOWN,
	SPINE_C,
	SPINE_T,
	SPINE_L,
	NEXTFIELD,
	DELETE,
	ANNOTATION,
	PREVFIELD,
	FAST_UP,
	FAST_DOWN,
	SIGNREPORT,
    ELLIPSE,
    ROI,
    INTERZOOM,
    HANG
};

const uint16_t PROGMEM keymaps[][MATRIX_ROWS][MATRIX_COLS] = {
    [0] = LAYOUT_tartarus2(
                ANNOTATION,   WL_SOFT,     WL_LUNG,   WL_VASCULAR,    ZOOM,      
                OPENEPIC,     WL_BONE,     SCROLLUP,   WL_BRAIN,    ARROW,       
                COPYACC,      FAST_UP,    SCROLLDOWN,  FAST_DOWN,   MEASURE,
                  OPENGE,     SPINE_C,     SPINE_T,     SPINE_L,    
                  SCROLLUP,   SCROLLDOWN,   MO(1),      DICTATE,      
                  KC_LEFT,      KC_UP,      KC_RGHT,   KC_DOWN
    
    [1] = LAYOUT_tartarus2(
                  KC_TRNS,     KC_TRNS,     KC_TRNS,     KC_TRNS,   INTERZOOM,      
                  KC_TRNS,  WL_HARDWARE, KC_MS_WH_UP,  WL_STROKE,    ELLIPSE,       
                  KC_TRNS,  WL_HARDWARE, KC_MS_WH_UP,  WL_STROKE,    ELLIPSE,       
                  KC_TRNS,     KC_TRNS,  KC_MS_WH_DOWN, FAST_DOWN,     ROI, 
                  OPENMCKESSON,   KC_TRNS,     KC_TRNS,     KC_TRNS,    
                  KC_TRNS,     KC_TRNS,     KC_TRNS,     KC_TRNS,      
                  KC_TRNS,     KC_TRNS,     KC_TRNS,     KC_TRNS,      
                  KC_TRNS,     KC_TRNS,     KC_TRNS,     KC_TRNS
           
    )
};

static uint16_t REP_DELAY = 290; // Common delay for both scroll up and down
static uint16_t REP_DELAY_FAST = 130; // Common delay for both scroll up and down

uint32_t wh_callback(uint32_t trigger_time, void* cb_arg) {
    bool is_up = (bool)cb_arg;
    if (is_up) {
        tap_code(KC_MS_WH_UP);
    } else {
        tap_code(KC_MS_WH_DOWN);
    }
    return REP_DELAY;
};

uint32_t wh_callback_fast(uint32_t trigger_time, void* cb_arg) {
    bool is_up = (bool)cb_arg;
    if (is_up) {
        tap_code(KC_MS_WH_UP);
    } else {
        tap_code(KC_MS_WH_DOWN);
    }
    return REP_DELAY_FAST;
};

bool process_record_user(uint16_t keycode, keyrecord_t *record) {

	static deferred_token token = INVALID_DEFERRED_TOKEN;

    switch (keycode) {

		case DICTATE: // Pastes the accession number in EPIC SEND_STRING(SS_TAP(X_F13));
			if (record->event.pressed) {
				SEND_STRING(SS_TAP(X_F13));
			}
		return false;

        case SCROLLUP:
            if (record->event.pressed) {
                if (token) {
                    cancel_deferred_exec(token);
                    token = INVALID_DEFERRED_TOKEN;
                } else {
                    tap_code(KC_MS_WH_UP);
                    token = defer_exec(REP_DELAY, wh_callback, (void*)true);
                }
            }
            return false;

        case SCROLLDOWN:
            if (record->event.pressed) {
                if (token) {
                    cancel_deferred_exec(token);
                    token = INVALID_DEFERRED_TOKEN;
                } else {
                    tap_code(KC_MS_WH_DOWN);
                    token = defer_exec(REP_DELAY, wh_callback, (void*)false);
                }
            }
            return false;

        case FAST_UP:
            if (record->event.pressed) {
                if (token) {
                    cancel_deferred_exec(token);
                    token = INVALID_DEFERRED_TOKEN;
                } else {
                    tap_code(KC_MS_WH_UP);
                    token = defer_exec(REP_DELAY_FAST, wh_callback_fast, (void*)true);
                }
            }
            return false;

        case FAST_DOWN:
            if (record->event.pressed) {
                if (token) {
                    cancel_deferred_exec(token);
                    token = INVALID_DEFERRED_TOKEN;
                } else {
                    tap_code(KC_MS_WH_DOWN);
                    token = defer_exec(REP_DELAY_FAST, wh_callback_fast, (void*)false);
                }
            }
            return false;

        case COPYACC:  // Copies the accession number to the clipboard
            if (record->event.pressed) {
                SEND_STRING(
                    SS_LSFT("`")
                    SS_LSFT("`")
                    SS_TAP(X_ENTER)
                    SS_DELAY(100)
                    SS_LSFT(SS_LCTL(SS_TAP(X_LEFT)))
                    SS_LCTL("c")
                    SS_LSFT(SS_TAP(X_HOME))
                    SS_TAP(X_DEL)
                    SS_TAP(X_DEL)
                );
            }
            return false;

        case OPENGE: // Pastes the accession number in GE PACs
            if (record->event.pressed) {
                SEND_STRING(
                    SS_LSFT(SS_TAP(X_TAB))
                    SS_TAP(X_END)
                    SS_DELAY(75)
                    SS_TAP(X_TAB)
                    SS_LCTL("v")
                    SS_DELAY(150)
                    SS_TAP(X_ENTER)
                );
            }
            return false;

        case OPENEPIC: // Pastes the accession number in EPIC
            if (record->event.pressed) {
                SEND_STRING(
                    SS_LCTL("2")
                    SS_DELAY(2500)
                    SS_LCTL("v")
                    SS_DELAY(500)
                    SS_TAP(X_ENTER)
                    SS_DELAY(2500)
                    SS_LALT(SS_LSFT("a"))
                );
            }
            return false;

        case OPENMCKESSON: // Pastes the accession number in GE PACs
            if (record->event.pressed) {
                SEND_STRING(
                    SS_LCTL("f")
                    SS_DELAY(500)
                    SS_TAP(X_BSPC)
                    SS_LCTL("v")
                    SS_TAP(X_ENTER)
                    SS_DELAY(500)
                    SS_TAP(X_ENTER)
                );
            }
            return false;

        case PASTE: // Pastes the accession number in EPIC
            if (record->event.pressed) {
                SEND_STRING(
                    SS_LCTL("v")
                );
            }
            return false;

		case WL_SOFT:
			if (record->event.pressed) {
				SEND_STRING(
					SS_TAP(X_BTN1)
					SS_DELAY(50)
					SS_TAP(X_KP_1)
				);
			}
		return false;

		case WL_BONE:
			if (record->event.pressed) {
				SEND_STRING(
					SS_TAP(X_BTN1)
					SS_DELAY(50)
					SS_TAP(X_KP_2)
				);
			}
		return false;

		case WL_BRAIN:
			if (record->event.pressed) {
				SEND_STRING(
					SS_TAP(X_BTN1)
					SS_DELAY(50)
					SS_TAP(X_KP_3)
				);
			}
		return false;

		case WL_STROKE:
			if (record->event.pressed) {
				SEND_STRING(
					SS_TAP(X_BTN1)
					SS_DELAY(50)
					SS_TAP(X_KP_4)
				);
			}
		return false;

		case WL_LUNG:
			if (record->event.pressed) {
				SEND_STRING(
					SS_TAP(X_BTN1)
					SS_DELAY(50)
					SS_TAP(X_KP_5)
				);
			}
		return false;

		case WL_HARDWARE:
			if (record->event.pressed) {
				SEND_STRING(
					SS_TAP(X_BTN1)
					SS_DELAY(50)
					SS_TAP(X_KP_6)
				);
			}
		return false;

		case WL_VASCULAR:
			if (record->event.pressed) {
				SEND_STRING(
					SS_TAP(X_BTN1)
					SS_DELAY(50)
					SS_TAP(X_KP_7)
				);
			}
		return false;

		case WL_SUBDURAL:
			if (record->event.pressed) {
				SEND_STRING(
					SS_TAP(X_BTN1)
					SS_DELAY(50)
					SS_TAP(X_KP_8)
				);
			}
		return false;

		case ARROW:
			if (record->event.pressed) {
				SEND_STRING(
					SS_TAP(X_BTN1)
					SS_DELAY(50)
					SS_TAP(X_A)
				);
			}
		return false;

		case ELLIPSE:
			if (record->event.pressed) {
				SEND_STRING(
					SS_TAP(X_BTN1)
					SS_DELAY(50)
					SS_TAP(X_E)
				);
			}
		return false;

		case MEASURE:
			if (record->event.pressed) {
				SEND_STRING(
					SS_TAP(X_BTN1)
					SS_DELAY(50)
					SS_TAP(X_M)
				);
			}
		return false;

		case ROI:
			if (record->event.pressed) {
				SEND_STRING(
					SS_TAP(X_BTN1)
					SS_DELAY(50)
					SS_LSFT(SS_TAP(X_E))
				);
			}
		return false;

		case ZOOM:
			if (record->event.pressed) {
				SEND_STRING(
					SS_TAP(X_BTN1)
					SS_DELAY(50)
					SS_TAP(X_Z)
				);
			}
		return false;

        case INTERZOOM:
			if (record->event.pressed) {
				SEND_STRING(
					SS_TAP(X_BTN1)
					SS_DELAY(50)
					SS_LSFT(SS_TAP(X_Z))
				);
			}
		return false;

 		case ANNOTATION:
			if (record->event.pressed) {
				SEND_STRING(
					SS_TAP(X_BTN1)
					SS_DELAY(50)
					SS_TAP(X_Y)
				);
			}
		return false;

 		case HANG:
			if (record->event.pressed) {
				SEND_STRING(
					SS_TAP(X_BTN1)
					SS_DELAY(50)
					SS_TAP(X_H)
				);
			}
		return false;

		case SPINE_C:
			if (record->event.pressed) {
				SEND_STRING(
					SS_TAP(X_BTN1)
					SS_DELAY(50)
					SS_TAP(X_C)
				);
			}
		return false;

		case SPINE_T:
			if (record->event.pressed) {
				SEND_STRING(
					SS_TAP(X_BTN1)
					SS_DELAY(50)
					SS_TAP(X_T)
				);
			}
		return false;

		case SPINE_L:
			if (record->event.pressed) {
				SEND_STRING(
					SS_TAP(X_BTN1)
					SS_DELAY(50)
					SS_TAP(X_L)
				);
			}
		return false;

		case DELETE:
			if (record->event.pressed) {
				SEND_STRING(
					SS_TAP(X_F15)
				);
			}
		return false;

    }
    return true; // Process all other keycodes normally.
}


config.h
#pragma once
#pragma weak backing_store_lock
#pragma weak backing_store_unlock

#define NO_DEBUG
#define NO_PRINT
#define FORCE_NKRO
#define TAPPING_TERM 300

#ifdef CRT0_EXTRA_CORES_NUMBER
#undef CRT0_EXTRA_CORES_NUMBER
#endif
#define CRT0_EXTRA_CORES_NUMBER 1


rules.mk
SRC += matrix.c c1_main.c c1_usbh.c tusb_os_custom.c
CUSTOM_MATRIX = lite
POINTING_DEVICE_DRIVER = custom


SRC += lib/Pico-PIO-USB/src/pio_usb.c
SRC += lib/Pico-PIO-USB/src/pio_usb_host.c
SRC += lib/Pico-PIO-USB/src/usb_crc.c
VPATH += keyboards/converter/adafruit_rp2040_usbh/lib/Pico-PIO-USB/src

SRC += lib/tinyusb/src/tusb.c
SRC += lib/tinyusb/src/common/tusb_fifo.c
SRC += lib/tinyusb/src/host/usbh.c
SRC += lib/tinyusb/src/host/hub.c
SRC += lib/tinyusb/src/class/hid/hid_host.c
SRC += lib/tinyusb/src/portable/raspberrypi/pio_usb/hcd_pio_usb.c
VPATH += keyboards/converter/adafruit_rp2040_usbh/lib/tinyusb/src

SRC += lib/pico-sdk/src/rp2_common/hardware_dma/dma.c
SRC += lib/pico-sdk/src/host/pico_stdlib/stdlib.c
VPATH += lib/pico-sdk/src/rp2_common/hardware_dma/include
VPATH += lib/pico-sdk/src/rp2_common/hardware_uart/include
VPATH += lib/pico-sdk/src/rp2_common/pico_stdio/include
VPATH += lib/pico-sdk/src/common/pico_stdlib/include
VPATH += lib/pico-sdk/src/common/pico_time/include
VPATH += lib/pico-sdk/src/common/pico_sync/include
VPATH += lib/pico-sdk/src/common/pico_util/include

MCU = RP2040
PLATFORM = chibios



tusb_os_custom.C
#include "ch.h"
#include "tusb_os_custom.h"

void osal_task_delay(uint32_t msec) {
    chThdSleepMilliseconds(msec);
}

bool osal_mutex_lock(osal_mutex_t mutex_hdl, uint32_t msec) {
    chSysLock();
    return true;
}

bool osal_mutex_unlock(osal_mutex_t mutex_hdl) {
    chSysUnlock();
    return true;
}

osal_mutex_t osal_mutex_create(osal_mutex_def_t *mdef) {
    return mdef;
}

bool osal_mutex_delete(osal_mutex_t mutex_hdl) {
  (void) mutex_hdl;
  return true; // nothing to do
}

#include <stdarg.h>

static char     debug_buffer[(1 << 12)];
static uint32_t write_index = 0;
static uint32_t read_index  = 0;

int tusb_debug_printf(const char *format, ...) {
    va_list va;
    va_start(va, format);

    int ret = 0;
    if (write_index >= read_index) {
        if (read_index == 0) {
            ret = vsnprintf(&debug_buffer[write_index], sizeof(debug_buffer) - write_index - 1, format, va);
        } else {
            ret = vsnprintf(&debug_buffer[write_index], sizeof(debug_buffer) - write_index, format, va);
        }
        write_index = (write_index + ret) & (sizeof(debug_buffer) - 1);
    }

    int32_t maxlen = read_index - write_index - 1;
    if (maxlen > 0) {
        int ret2    = vsnprintf(&debug_buffer[write_index], maxlen, format, va);
        write_index = (write_index + ret2) & (sizeof(debug_buffer) - 1);
        ret += ret2;
    }

    va_end(va);

    return ret;
}

void tusb_print_debug_buffer(void) {
    while (read_index != write_index) {
        printf("%c", debug_buffer[read_index]);
        read_index = (read_index + 1) & (sizeof(debug_buffer) - 1);
    }
}



tusb_os_custom.h

#pragma once
#ifdef __cplusplus
 extern "C" {
#endif

typedef uint8_t osal_mutex_def_t, *osal_mutex_t;
void osal_task_delay(uint32_t msec);
osal_mutex_t osal_mutex_create(osal_mutex_def_t* mdef);
bool osal_mutex_lock (osal_mutex_t mutex_hdl, uint32_t msec);
bool osal_mutex_unlock(osal_mutex_t mutex_hdl);
bool osal_mutex_delete(osal_mutex_t mutex_hdl);
#include "common/tusb_fifo.h"
typedef struct
{
    tu_fifo_t ff;
    osal_mutex_def_t mutex;
} osal_queue_def_t;

typedef osal_queue_def_t* osal_queue_t;

static inline void _osal_q_lock(osal_queue_t qhdl) {
    osal_mutex_lock(&qhdl->mutex,0);
}
static inline void _osal_q_unlock(osal_queue_t qhdl){
    osal_mutex_unlock(&qhdl->mutex);
}

#define OSAL_QUEUE_DEF(_int_set, _name, _depth, _type)       \
  uint8_t _name##_buf[_depth*sizeof(_type)];              \
  osal_queue_def_t _name = {                              \
    .ff = TU_FIFO_INIT(_name##_buf, _depth, _type, false) \
  }

TU_ATTR_ALWAYS_INLINE static inline osal_queue_t osal_queue_create(osal_queue_def_t* qdef)
{
  tu_fifo_clear(&qdef->ff);
  osal_mutex_create(&qdef->mutex);
  return (osal_queue_t) qdef;
}

TU_ATTR_ALWAYS_INLINE static inline bool osal_queue_receive(osal_queue_t qhdl, void* data, uint32_t msec)
{
  (void) msec; // not used, always behave as msec = 0

  _osal_q_lock(qhdl);
  bool success = tu_fifo_read(&qhdl->ff, data);
  _osal_q_unlock(qhdl);

  return success;
}

TU_ATTR_ALWAYS_INLINE static inline bool osal_queue_send(osal_queue_t qhdl, void const * data, bool in_isr)
{
  (void) in_isr;

  _osal_q_lock(qhdl);
  bool success = tu_fifo_write(&qhdl->ff, data);
  _osal_q_unlock(qhdl);

  TU_ASSERT(success);

  return success;
}

TU_ATTR_ALWAYS_INLINE static inline bool osal_queue_empty(osal_queue_t qhdl)
{
  return tu_fifo_empty(&qhdl->ff);
}

TU_ATTR_ALWAYS_INLINE static inline bool osal_queue_delete(osal_queue_t qhdl) {
  (void) qhdl;
  return true; 
}

#ifdef __cplusplus
 }
#endif




Updated Requirements Document: USB-to-USB Converter with PowerMic Button Emulation

Project Overview:
This project aims to develop a USB-to-USB converter using the Adafruit RP2040 USB Host board. The converter will receive input from a Razer Tartarus keypad connected to the RP2040’s USB-A port and serve as a virtual QMK keyboard and PowerMic interface to the attached computer via the USB-C port. 

Key Objective:
1.  Emulate the PowerMic Button Interface (Not the Device): The primary goal is to cause Powerscribe to react in the same manner as it would when the buttons on a PowerMic are pressed by providing an identical interface, reports, and data for the button presses and releases.
2.  Do Not Emulate the PowerMic Device Identity: The device should not present itself as a PowerMic. All device identifiers such as the VID, PID, manufacturer, product name, and version must remain as per the current settings.
Important Note:
3.  Retain Existing Functionalities: The converter must retain all existing functionalities and device enumerations as per the base code from https://github.com/whyaaronbailey/adafruit_rp2040_usbh. Do not remove or alter host functions or interfaces unrelated to the PowerMic button emulation.
---
Functional Requirements
1. Device Identification

•  Vendor ID (VID): 0xFEED (Must remain unchanged)
•  Product ID (PID): 0x0000 (Must remain unchanged)
•  Device Version: 0x0100 (Version 1.0.0)
•  Manufacturer: "AltI" (As specified in info.json)
•  Product Name: "RadPad" (As specified in info.json)
•  Serial Number: None

2. Device Enumeration
The device must enumerate the same functionalities as per the base code and the usb_base_github.txt capture:
[1-3]: Adafruit Rp2040 USB Host
|---USB Input Device
|   \---HID-compliant vendor-defined device
|---USB Serial Device (COM Port)
|---USB Input Device
|   |---HID-compliant system controller
|   |---HID-compliant consumer control device
|   |---HID-compliant mouse
|   \---HID Keyboard Device
\---USB Input Device
    \---HID Keyboard Device

•  Do Not Change: Retain all existing interfaces, functions, and enumerated devices.

3. Interfaces and Endpoints
PowerMic HID Interface
•  Interface Number: 3 (Interface 3)
•  Endpoint Address: 0x81 (Endpoint 1 IN)
•  Endpoint Type: Interrupt
•  Endpoint Max Packet Size: As per the existing configuration
•  Polling Interval: 10ms
Other Interfaces
•  Keyboard HID Interface: Retain existing configurations.
•  Other Functions: Retain all other interfaces and endpoints as per the base code.
4. HID Report Descriptor for PowerMic Interface
// HID Report Descriptor for PowerMic Interface. Replace all placeholders with required data.

// PowerMic HID Report Descriptor
uint8_t const hid_report_desc_powermic[] = {
    // Usage Page (Generic Desktop Controls)
    0x05, 0x01,        // Usage Page (Generic Desktop Controls)
    0x09, 0x00,        // Usage (Undefined)
    0xA1, 0x01,        // Collection (Application)
    
    // LED Report - Included for compatibility but unused
    0x05, 0x08,        // Usage Page (LEDs)
    0x09, 0x4B,        // Usage (Generic Indicator)
    0x15, 0x00,        // Logical Minimum (0)
    0x25, 0x01,        // Logical Maximum (1)
    0x95, 0x08,        // Report Count (8)
    0x75, 0x01,        // Report Size (1)
    0x91, 0x02,        // Output (Data, Var, Abs)
    
    // Button Input Report
    0x05, 0x09,        // Usage Page (Button)
    0x15, 0x00,        // Logical Minimum (0)
    0x25, 0x01,        // Logical Maximum (1)
    0x75, 0x01,        // Report Size (1)
    0x95, 0x08,        // Report Count (8)
    0x81, 0x03,        // Input (Const, Var, Abs) - Padding

    // Button Usages
    0x19, 0x01,        // Usage Minimum (Button 1)
    0x29, 0x0E,        // Usage Maximum (Button 14)
    0x15, 0x00,        // Logical Minimum (0)
    0x25, 0x01,        // Logical Maximum (1)
    0x95, 0x0E,        // Report Count (14)
    0x81, 0x02,        // Input (Data, Var, Abs)

    // Padding
    0x95, 0x02,        // Report Count (2)
    0x81, 0x03,        // Input (Const, Var, Abs) - Padding

    // Vendor-Defined Feature Report
    0x06, 0x00, 0xFF,  // Usage Page (Vendor-Defined 0xFF00)
    0x09, 0x00,        // Usage (Undefined)
    0x15, 0x00,        // Logical Minimum (0)
    0x26, 0xFF, 0x00,  // Logical Maximum (255)
    0x75, 0x08,        // Report Size (8 bits)
    0x95, 0x27,        // Report Count (39 bytes)
    0xB1, 0x00,        // Feature (Data, Array, Abs)

    0xC0               // End Collection
};

// Configuration Descriptor with placeholders for Interface 0, 1, 2
uint8_t const desc_configuration[] = {
    // Configuration Descriptor
    0x09,                            // bLength
    TUSB_DESC_CONFIGURATION,         // bDescriptorType
     0x00, 0x00,                     // wTotalLength (will be calculated)
    ITF_NUM_TOTAL,                   // bNumInterfaces
    0x01,                            // bConfigurationValue
    0x00,                            // iConfiguration
    0xA0,                            // bmAttributes (Bus-powered, Remote Wakeup)
    0xFA,                            // bMaxPower (500 mA)

    // Interface 0: Placeholder
    TUD_INTERFACE_DESCRIPTOR(0, 0x03, 0x00, 0x00, 0x00, 0x00), // Class 0x03 = HID

    // Interface 1: USB Serial Device (COM Port)
     TUD_INTERFACE_DESCRIPTOR(1, 0x02, 0x02, 0x01, 0x00, 0x00), // Class 0x02=CDC, Subclass=0x02, Protocol=0x01
  
    // Interface 2: HID-compliant system controller/consumer/mouse/keyboard
    TUD_INTERFACE_DESCRIPTOR(2, 0x03, 0x00, 0x00, 0x00, 0x00),  // Class 0x03 = HID

    // Interface 3: PowerMic HID
    TUD_HID_DESCRIPTOR(ITF_NUM_POWERMIC, 0x00, HID_ITF_PROTOCOL_NONE,
                       sizeof(hid_report_desc_powermic), EPNUM_POWERMIC, CFG_TUD_HID_EP_BUFSIZE, 10),

    // Interface 4: Keyboard HID
    TUD_HID_DESCRIPTOR(ITF_NUM_KEYBOARD, 0x00, HID_ITF_PROTOCOL_KEYBOARD,
                       sizeof(hid_report_desc_keyboard), EPNUM_KEYBOARD, CFG_TUD_HID_EP_BUFSIZE, 10),
};


Explanation:
•  Defines a vendor-defined HID report descriptor with a 3-byte input report.
•  Matches the PowerMic's button report format required by Powerscribe.
5. Button Codes and Reports
Button Codes (3-byte Values)
•  Enter/Select: {0x00, 0x00, 0x01}
•  Custom Right: {0x00, 0x00, 0x02}
•  Transcribe: {0x00, 0x01, 0x00}
•  Tab Back: {0x00, 0x02, 0x00}
•  Dictate: {0x00, 0x04, 0x00}
•  Tab Forward: {0x00, 0x08, 0x00}
•  Rewind: {0x00, 0x10, 0x00}
•  Fast Forward: {0x00, 0x20, 0x00}
•  Stop/Play: {0x00, 0x40, 0x00}
•  Custom Left: {0x00, 0x80, 0x00}
•  Trigger: {0x01, 0x00, 0x00}
•  Release: {0x00, 0x00, 0x00}

static const uint8_t PM_ENTER_CODE[3]      = {0x00, 0x00, 0x01};
static const uint8_t PM_CUSTOM_R_CODE[3]   = {0x00, 0x00, 0x02};
static const uint8_t PM_TRANSCRIBE_CODE[3] = {0x00, 0x01, 0x00};
static const uint8_t PM_TAB_BACK_CODE[3]   = {0x00, 0x02, 0x00};
static const uint8_t PM_DICTATE_CODE[3]    = {0x00, 0x04, 0x00};
static const uint8_t PM_TAB_FWD_CODE[3]    = {0x00, 0x08, 0x00};
static const uint8_t PM_REWIND_CODE[3]     = {0x00, 0x10, 0x00};
static const uint8_t PM_FFWD_CODE[3]       = {0x00, 0x20, 0x00};
static const uint8_t PM_STOP_PLAY_CODE[3]  = {0x00, 0x40, 0x00};
static const uint8_t PM_CUSTOM_L_CODE[3]   = {0x00, 0x80, 0x00};
static const uint8_t PM_TRIGGER_CODE[3]    = {0x01, 0x00, 0x00};
static const uint8_t PM_RELEASE_CODE[3]    = {0x00, 0x00, 0x00};

Report Format
•  Report Length: 3 bytes [Byte1][Byte2][Byte3]
•  Button Press Report: Send the corresponding button code.
•  Button Release Report: Send {0x00, 0x00, 0x00}
Timing Characteristics
•  Button Press Duration: 120ms ±5ms
•  Interrupt Polling Interval: 10ms
•  Response Time: Device must respond to host requests within 1ms
•  Minimum Time Between Reports: 10ms
6. Implementation in keymap.c

•  Map Keycodes from Razer Tartarus to PowerMic Button Codes:
In the keymaps/tartarus_pacs/keymap.c file:
•  Define custom keycodes for the PowerMic buttons.
•  Use the process_record_user function to send the appropriate HID reports when the keys are pressed.
Example Implementation:
#include QMK_KEYBOARD_H
#include "tusb.h"

// Define custom keycodes
enum custom_keycodes {
    PM_ENTER = SAFE_RANGE,
    PM_CUSTOM_R,
    PM_TRANSCRIBE,
    // ... other custom keycodes
};

// PowerMic button codes
static const uint8_t PM_ENTER_CODE[3]      = {0x00, 0x00, 0x01};
static const uint8_t PM_CUSTOM_R_CODE[3]   = {0x00, 0x00, 0x02};
static const uint8_t PM_RELEASE_CODE[3]    = {0x00, 0x00, 0x00};
// ... other button codes

// Function to process PowerMic button presses
void process_powermic_button(const uint8_t* button_code) {
    // Send the button press report
    tud_hid_n_report(ITF_NUM_POWERMIC, 0, button_code, 3);

    // Wait for 120ms ±5ms
    wait_ms(120);

    // Send the release report
    tud_hid_n_report(ITF_NUM_POWERMIC, 0, PM_RELEASE_CODE, 3);
}

// Process custom keycodes
bool process_record_user(uint16_t keycode, keyrecord_t *record) {
    if (record->event.pressed) {
        switch (keycode) {
            case PM_ENTER:
                process_powermic_button(PM_ENTER_CODE);
                return false;
            case PM_CUSTOM_R:
                process_powermic_button(PM_CUSTOM_R_CODE);
                return false;
            // ... other cases
        }
    }
    return true;
}
Notes:
•  Ensure that ITF_NUM_POWERMIC corresponds to Interface 3.
•  Use tud_hid_n_report() to send reports over the correct endpoint (0x81).
7. info.json Settings
Ensure that info.json contains the following, and do not change these settings:
{
    "manufacturer": "AltI",
    "keyboard_name": "RadPad",
    "usb": {
        "vid": "0xFEED",
        "pid": "0x0000",
        "device_version": "1.0.0"
    },
    // ... other configurations ...
}
8. USB Stack and Libraries
•  The codebase uses both TinyUSB and ChibiOS commands.
•  Do not disable ChibiOS, as it is used in the existing codebase (e.g., in c1_main.c).
•  Ensure that TinyUSB and ChibiOS coexist without conflicts.

9. Files Requiring Changes
Limit code modifications to the minimum necessary. The primary files to be updated are:
•  usb_descriptors.c: For the HID Report Descriptor and ensuring the correct interface and endpoint settings.
•  keymap.c: For handling PowerMic button mappings and sending the correct HID reports.
Config.h: do NOT duplicate data that already exists in info.json (e.g., vid, pid, version, manufacturer).
NEVER EVER EVER EVER PUT IN PLACEHOLDERS IN ANY CODE

10. Do Not Alter Host Functions
•  Do not remove or alter existing host functionalities.
•  All existing functions and enumerations must remain as per the base code.
•  The device should continue to enumerate the same interfaces, including:
All the devices enumerated:
•  HID-compliant keyboard
•  HID-compliant mouse
•  HID-compliant vendor-defined device
•  USB Serial Device

11. Device Behavior
•  The device should send sending HID reports identical to those sent by the PowerMic's button interface over the correct endpoint (0x81) and interface (3) to the Powerscribe application.
•  By doing so, Powerscribe will react in the same manner as it would to an authentic PowerMic's button presses.
•  Critical Distinction: The device should not impersonate the PowerMic in terms of identity (VID, PID, product name, etc.), but only replicate the interface and HID reports relevant to the PowerMic's buttons.
